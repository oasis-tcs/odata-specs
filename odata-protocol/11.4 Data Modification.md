## ##subsec Data Modification

Updatable OData services support Create, Update, and Delete operations
for some or all exposed entities. Additionally, [Actions](#Actions)
supported by a service can affect the state of the system.

A successfully completed [Data Modification Request](#DataModification)
must not violate the integrity of the data.

The client may request whether content be returned from a Create,
Update, or Delete request, or the invocation of an Action, by specifying
the [`return`](#Preferencereturnrepresentationandreturnminimal) preference.
A [success response](#SuccessResponses) indicates that data have been modified,
regardless of whether the requested content could be returned.

### ##subsubsec Common Data Modification Semantics

[Data Modification Requests](#DataModification) share the following
semantics.

#### ##subsubsubsec Atomicity

Data modification requests guarantee _atomicity_ in the following sense:
When the request completes, every subsequent request observes a state of the system
in which either all or none of the changes have been carried out.
The experience of concurrent clients observing the state of the system
can be described through isolation levels as defined in [SQL92, section 4.28](#_SQL92),
even for services that do not use a transactional database.

When a service operates at isolation level "read uncommitted",
concurrent clients MAY observe a state of the system where the changes have been carried out only partially
while the data modification request is still being executed.
In such a case, if an error is encountered while processing the request, the service MUST roll back any changes that
have been applied (even though they may have been seen by clients).

When a service operates at an isolation level of "read committed" or higher,
it protects against seeing such partial changes.

When data modification requests apply the
[`continue-on-error`](#Preferencecontinueonerrorodatacontinueonerror) preference,
they do not guarantee atomicity. See the sections below where this preference is mentioned.

#### ##subsubsubsec Use of ETags for Avoiding Update Conflicts

Each entity has its own ETag value that MUST change when structural
properties or links from that entity have changed. In addition,
modifying, adding, or deleting a contained entity MAY change the ETag of
the parent entity.

Collections of entities (including collections of related entities) MAY
have their own ETag value whose semantics is service-specific. It
typically changes if entities are added to or removed from the
collection, or if an entity in the collection is changed. The ETag of a
collection of related entities reached via a navigation property MAY
differ from the ETag of the entity containing the navigation property.

A [Data Modification Request](#DataModification) on an existing resource
or an [Action Request](#Actions) invoking an action bound to an existing
resource MAY require optimistic concurrency control. Services SHOULD
announce this via annotations with the terms
[Core.OptimisticConcurrency]{.term} in
[OData-VocCore](#ODataVocCore) and
[Capabilities.NavigationRestrictions]{.term}
(nested property `OptimisticConcurrencyControl`) in
[OData-VocCap](#ODataVocCap).

If optimistic concurrency control is required for a resource, the
service MUST include an [`ETag`](#HeaderETag) header in a response to a
`GET` request to the resource, and MAY include the ETag in a
format-specific manner in responses containing that resource,
see for example [#OData-JSON#ControlInformationetagodataetag].

The presence of an [`ETag`](#HeaderETag) header in a response does not
imply in itself that the resource requires optimistic concurrency
control; the ETag may just be used for caching and/or conditional `GET`
requests.

If an ETag value is specified in an [`If-Match`](#HeaderIfMatch) or
[`If-None-Match`](#HeaderIfNoneMatch) header of a [Data Modification
Request](#DataModification) or [Action Request](#Actions), the operation
MUST only be invoked if the `If-Match` or `If-None-Match` condition is
satisfied.

If the client does not specify an [`If-Match`](#HeaderIfMatch) request
header in a [Data Modification Request](#DataModification) or [Action
Request](#Actions) on a resource that requires optimistic concurrency
control, the service responds with a `428 Precondition Required` and
MUST ensure that no observable change occurs as a result of the request.
Clients can attempt to disable optimistic concurrency control by
specifying `If-Match` with a value of `*`. Services MAY reject such
requests.

For requests including an [`OData-Version`](#HeaderODataVersion) header
value of `4.01`, any ETag values specified in the request body of a
[request to modify an entity](#UpdateanEntity) MUST be `*` or match the current value
for the record being updated.

::: example
Example ##ex_antietag: `Category` is a single-valued nullable non-containment navigation property
on the product entity type. Note that an ETag used in the `If-Match` header in the following request
applies to the category currently associated with the product.
```json
PATCH http://host/service/Products(57)/Category
If-Match: "<ETag>"

{"CategoryID": 5}
```
To make the category
update conditional on the ETag of the product, the following request could be made instead:
```json
PATCH http://host/service/Products(57)
If-Match: "<ETag>"

{"Category": {"CategoryID": 5}}
```
:::

#### ##subsubsubsec Handling of DateTimeOffset Values

Services SHOULD preserve the offset of `Edm.DateTimeOffset` values, if
possible. However, where the underlying storage does not support offset
services may be forced to normalize the value to some common time zone
(for example UTC) in which case the result would be returned with that time
zone offset. If the service normalizes values, it MUST fail evaluation
of the [query functions](#BuiltinQueryFunctions) `year`, `month`, `day`,
`hour`, and `time` for literal values that are not stated in the time
zone of the normalized values.

#### ##subsubsubsec Handling of Properties Not Advertised in Metadata

Clients MUST be prepared to receive additional properties in an entity
or complex type instance that are not advertised in metadata, even for
types not marked as open. By using `PATCH` when [updating
entities](#UpdateanEntity), clients can ensure that such properties
values are not lost if omitted from the request.

#### ##subsubsubsec Handling of Integrity Constraints

Services may impose cross-entity integrity constraints. Certain
referential constraints, such as requiring an entity to be created with
related entities can be satisfied through
[creating](#CreateRelatedEntitiesWhenCreatinganEntity) or
[linking](#LinktoRelatedEntitiesWhenCreatinganEntity) related entities when
creating the entity. Other constraints might require multiple changes to
be processed in an all-or-nothing fashion.

#### ##subsubsubsec Returning Results from Data Modification Requests

Clients can request whether created or modified resources are returned
from [create](#CreateanEntity), [update](#UpdateanEntity), and
[upsert](#UpsertanEntity) operations using the
[`return`](#Preferencereturnrepresentationandreturnminimal) preference header. In
the absence of such a header, services SHOULD return the created or
modified content unless the resource is a stream property value.

When returning content other than for an update to a media entity
stream, services MUST return the same content as a subsequent request to
retrieve the same resource. For updating media entity streams, the
content of a non-empty response body MUST be the updated media entity.

Requests that return a single instance of a structured type or a
collection of structured type instances MAY specify the system query
options [`$expand`](#SystemQueryOptionexpand) and
[`$select`](#SystemQueryOptionselect).

Requests that return a collection MAY specify the system query option
[`$filter`](#SystemQueryOptionfilter).

If one or more of these query options are present, this implies a
`return=representation` preference if no
[`return`](#Preferencereturnrepresentationandreturnminimal) preference is
specified.

If one or more of these query options are present with a
`return=minimal` preference, the service SHOULD NOT return a
representation and MUST include a
[`Preference-Applied`](#HeaderPreferenceApplied) header if it does not
return a representation.

If one or more of these query options are present and the service
returns a representation, then the service MUST apply the specified
query options. If it cannot apply the specified query options
appropriately, it MUST NOT fail the request solely due to the presence
of these query options and instead MUST return [`204 No Content`](#ResponseCode204NoContent).

### ##subsubsec Create an Entity

To create an entity in a collection, the client sends a `POST` request
to a resource path addressing that collection. The `POST` body MUST contain a single valid
representation of an entity of the declared target entity type,
or one of its derived types.

The resource path need not be the canonical URL for the collection; for example,
it could represent a non-containment navigation property.
In such a case, the service may be able to determine the canonical collection (as defined in [section ##ContextURL])
through a navigation property path binding [#OData-CSDL#NavigationPropertyPathBinding]
or through the presence of a context URL within the payload.
If the service is unable to determine the canonical collection for the entity, it MUST fail the request.

The service MUST fail the request if the
body of the request specifies a key that already exists in the determined collection.
Otherwise the entity is created in the determined collection and,
if the resource path ends with a non-containment navigation property,
also linked to the entity containing the navigation property.

The entity representation MAY reference existing
entities as well as define content for new related entities. The result of the
operation is the entity with relationships to all referenced existing
entities as well as all related entities created inline.

If the request includes a related entity type that supports user-specified key values, 
or server generated keys with user-specified alternate key values, and the request 
specifies the full set of primary or alternate key values 
that do not match an existing entity, then a 
[new entity is created](#CreateRelatedEntitiesWhenCreatinganEntity) with the provided 
values and associated with the target entity. If a related
entity specifies the full set of (primary or alternate) key values of an existing entity, then 
[a relationship is established to that existing entity](#LinktoRelatedEntitiesWhenCreatinganEntity). 
If both primary and alternate key values are specified, they MUST 
identify the same entity.

An entity may also be created as the result of a `PATCH` or `PUT` request
that is [treated as an insert](#UpsertanEntity).

If the resource path terminates in a type cast segment, then the segment
MUST specify the type of, or a type derived from, the type of the
collection, and the entity MUST be created as that specified type.

To create an _open entity_ (an instance of an open type), additional
property values beyond those specified in the metadata MAY be sent in
the request body. The service MUST treat these as dynamic properties and
add them to the created instance.

If the entity being created is not an open entity, additional property
values beyond those specified in the metadata SHOULD NOT be sent in the
request body. The service MUST fail if unable to persist all property
values specified in the request.

Non-insertable properties SHOULD be omitted from the request body.
If they are provided, services MUST either ignore the values in the request body or fail the request
if the provided values do not match the service-determined values.

Non-insertable properties include (and are not limited to)

- dependent properties that are tied to non-key properties of the principal entity through a referential constraint [#OData-CSDL#ReferentialConstraint] (informally: "denormalized" properties),
- properties annotated with the term
  [Core.Computed]{.term}, see [OData-VocCore](#ODataVocCore),
- properties listed as `NonInsertableProperties` of term [Capabilities.InsertRestrictions]{.term}, see [OData-VocCap](#ODataVocCap),
- properties annotated with term
  [Core.Permissions]{.term}, see [OData-VocCore](#ODataVocCore), where the annotation value does not have the `Write` flag.

Services MUST return an error if the request body contains a value for a property that in principle can be specified on insert but the request cannot currently be executed respecting the specified value, for example, due to permissions or state of the object.
Properties with a default value, nullable properties, and
collection-valued properties omitted from the request are set to the
default value, null, or an empty collection, respectively.

Services MAY add dynamic properties to the created entity as long as their names do not conflict with the names of declared properties and client-specified dynamic properties.

Upon successful creation of the entity, the service MUST respond with either
[`201 Created`](#ResponseCode201Created) and a representation of the
created entity, or [`204 No Content`](#ResponseCode204NoContent) if the
request included a
[`return=minimal`](#Preferencereturnrepresentationandreturnminimal) preference and did not
include the system query options [`$select`](#SystemQueryOptionselect)
and [`$expand`](#SystemQueryOptionexpand), or if a representation of the created
entity could not be constructed. In either case, if the service is able to construct
the edit URL or read URL of the created entity, the response MUST contain that URL in a
[`Location`](#HeaderLocation) header.

#### ##subsubsubsec Link to Related Entities When Creating an Entity

To create a new entity with links to existing entities in a single
request, the client includes references to the related entities in the
request body.

The representation for referencing related entities is format-specific.

::: example
Example ##ex: using the JSON format, 4.0 clients can create a new manager
entity with links to an existing manager (of managers) and to two existing employees by applying the `odata.bind`
annotation to the `Manager` and `DirectReports` navigation properties

```json
{
  "@type": "#Northwind.Manager",
  "ID": 1,
  "FirstName": "Pat",
  "LastName": "Griswold",
  "Manager@odata.bind": "http://host/service/Employees(0)",
  "DirectReports@odata.bind": [
    "http://host/service/Employees(5)",
    "http://host/service/Employees(6)"
  ]
}
```

:::

::: example
Example ##ex: using the JSON format, 4.01 clients can create a new manager
entity with links to an existing manager (of managers) and to two existing employees by including 
either the entity-ids or full set of key properties within the `Manager` and `DirectReports` navigation properties

```json
{
  "@type": "#Northwind.Manager",
  "ID": 1,
  "FirstName": "Pat",
  "LastName": "Griswold",
  "Manager": { "id": 0 },
  "DirectReports": [{ "@id": "Employees(5)" }, { "id": 6 }]
}
```

:::

Upon successful completion of the operation, the service creates the
requested entity and relates it to the requested existing entities.

Properties of related entities may be updated by supplying property
values for the related entities. Upon successful completion of
the operation, in addition to creating the entity and relating it to the
requested entities, the properties of the existing entities are updated
using `PATCH` semantics as described in [Update an Entity](#UpdateanEntity).

::: example
Example ##ex: using the JSON format, 4.01 clients can update the
`TeamName` property of existing direct reports when relating them
to the new manager.

```json
{
  "@type": "#Northwind.Manager",
  "ID": 1,
  "FirstName": "Pat",
  "LastName": "Griswold",
  "Manager": { "id": 0 },
  "DirectReports": [
    { 
      "@id": "Employees(5)",
      "TeamName": "Pat's Team"
    },
    { 
      "id": 6,
      "TeamName": "Pat's Team"
    }
  ]
}
```

:::

If the target URL for the collection the entity is created in and
binding information provided in the `POST` body contradicts the implicit
binding information provided by the request URL, the request MUST fail,
and the service responds with `400 Bad Request`.

Upon failure of the operation, the service MUST NOT create the new
entity nor update any related entities. In particular, the service 
MUST never create an entity in a partially valid state
(with the navigation property unset).

#### ##subsubsubsec Create Related Entities When Creating an Entity

A request to create an entity that includes related entities,
represented using the appropriate inline representation, is referred to
as a "deep insert".

Media entities MUST contain the format-specific representation of
their media stream as a virtual property `$value` when nested within a
deep insert.

Each included related entity is processed observing the rules for
[creating an entity](#CreateanEntity) as if it was posted against the
original target URL extended with the navigation path to this related
entity.

On success, the service MUST create all entities and relate them. If the
service responds with [`201 Created`](#ResponseCode201Created) then, in the absence of
an explicit `$expand`, the response MUST be expanded to include at least the entities 
and properties that were specified in the deep-insert request.

Clients MAY associate an id with individual nested entities in the
request by applying the
[Core.ContentID]{.term}
term using the namespace or alias defined for the [OData-VocCore](#ODataVocCore) vocabulary in the service's `$metadata` document. Services that respond
with [`201 Created`](#ResponseCode201Created) SHOULD annotate the entities in the response using
the same
[Core.ContentID]{.term}
value as specified in the request. Services SHOULD advertise support for
deep inserts, including support for returning the
[Core.ContentID]{.term},
through the
[Capabilities.DeepInsertSupport]{.term}
term, defined in [OData-VocCap](#ODataVocCap); services that advertise
support through
[Capabilities.DeepInsertSupport]{.term}
MUST return the
[Core.ContentID]{.term} for
the inserted or updated entities.

The `continue-on-error` preference is not supported for deep insert
operations.

On failure, the service MUST NOT create any of the entities.

### ##subsubsec Update an Entity

To make changes to an entity, the client makes a `PATCH` or `PUT`
request to a URL that identifies the entity. The [edit URL](#ReadURLsandEditURLs)
MAY differ from the canonical URL defined in [#OData-URL#CanonicalURL],
in which case clients SHOULD use the edit URL when making changes to the entity.

The body of the request MUST be a valid representation of the
declared target entity type, or one of its derived types.

Services SHOULD support `PATCH` as the preferred means of updating an
entity. `PATCH` provides more resiliency between clients and services by
directly modifying only those values specified by the client.

The semantics of `PATCH`, as defined in [RFC5789](#rfc5789), is to merge
the content in the request payload with the entity's current state,
applying the update only to those components specified in the request
body. Collection properties and primitive properties provided in the
payload corresponding to updatable properties MUST replace the value of
the corresponding property in the entity or complex type.
Complex properties are updated by applying `PATCH` semantics recursively,
see also [section ##UpdateaComplexProperty].
Omitted properties of the containing entity or complex property, including
dynamic properties, MUST NOT be directly altered unless as a side effect
of changes resulting from the provided properties.

If the type of the entity in a `PATCH` request differs from the type
of the entity being updated (i.e., a different derived type of the
declared target type), then properties shared through inheritance,
as well as dynamic properties, are retained (unless overwritten by
new values in the payload). Other properties of the original type are discarded.

Services MAY additionally support `PUT` but should be aware of the
potential for data-loss in round-tripping properties that the client may
not know about in advance, such as open or added properties, or
properties not specified in metadata. Services that support `PUT` MUST
replace all values of structural properties with those specified in the
request body. Omitted non-key, updatable structural properties not
defined as dependent properties within a referential constraint MUST be
set to their default values. Omitting a non-nullable property with no
service-generated or default value from a `PUT` request results in a
`400 Bad Request` error. Omitted dynamic properties MUST be
removed, set to `null`, or set to a service-generated value.

For requests with an `OData-Version` header with a value of `4.01` or
greater, the media stream of a media entity can be updated by specifying
the format-specific representation of the media stream as a virtual
property `$value`.

Updating a dependent property that is tied to a key property of the
principal entity through a referential constraint updates the
relationship to point to the entity with the specified key value. If
the canonical collection (as defined in [section ##ContextURL]) for that entity cannot be determined or does not contain
such an entity, the update fails. The canonical collection is known for referential constraints on
containment navigation properties, and can be determined in the presence of navigation property
bindings or a context URL in the request payload, or through service specific knowledge.

Updating a principal property that is tied to a dependent entity through
a referential constraint on the dependent entity updates the dependent
property.

Non-updatable properties SHOULD be omitted from the request body.
If they are provided, services MUST either ignore the values in the request body or fail the request if the provided values do not match the service-determined values.

Non-updatable properties include (and are not limited to)

- key properties,
- dependent properties that are tied to non-key properties of the principal entity through a referential constraint [#OData-CSDL#ReferentialConstraint] (informally: "denormalized" properties),
- properties annotated with the terms
  [Core.Computed]{.term} or [Core.Immutable]{.term}, see [OData-VocCore](#ODataVocCore),
- properties listed as `NonUpdatableProperties` of term [Capabilities.UpdateRestrictions]{.term}, see [OData-VocCap](#ODataVocCap),
- properties annotated with term
  [Core.Permissions]{.term}, see [OData-VocCore](#ODataVocCore), where the annotation value does not have the `Write` flag.

Services MUST return an error if the request body contains a value for a
property that in principle can be specified on update but the request cannot currently be executed respecting the specified value, for example, due to permissions or state of the object.

Clients SHOULD use `PATCH` and specify only those properties intended to be changed.

The entity-id cannot be changed when updating an entity.
However, format-specific rules might in some cases require providing
the entity-id in the payload when requesting the update.

For requests with an `OData-Version` header with a value of `4.01` or
greater, if the entity representation in the request body includes an
ETag value, the update MUST NOT be performed and SHOULD return
[`412 Precondition Failed`](#ResponseCode412PreconditionFailed) if the
supplied ETag value is not `*` and does not match the current ETag value
for the entity. ETag values in request bodies MUST be ignored for
requests containing an OData-Version header with a value of `4.0`.

If an update specifies both a binding to a single-valued navigation
property and a dependent property that is tied to a key property of the
principal entity according to the same navigation property, then the
dependent property is ignored, and the relationship is updated according
to the value specified in the binding.

If the entity being updated is open, then additional values for
properties beyond those specified in the metadata or returned in a
previous request MAY be sent in the request body. The service MUST treat
these as dynamic properties.

If the entity being updated is not open, then additional values for
properties beyond those specified in the metadata or returned in a
previous request SHOULD NOT be sent in the request body. The service
MUST fail if it is unable to persist all updatable property values
specified in the request.

Upon successful completion of the update, the service responds with either
[`200 OK`](#ResponseCode200OK) and a representation of the updated
entity, or [`204 No Content`](#ResponseCode204NoContent).
The client may
request that the response SHOULD include a body by specifying a
[`return=representation`](#Preferencereturnrepresentationandreturnminimal) preference, or by
specifying the system query options
[`$select`](#SystemQueryOptionselect) or
[`$expand`](#SystemQueryOptionexpand).
An entity that requires concurrency control
and is included in the response MUST include an ETag.
If a representation of the updated entity could not be constructed,
the service MAY ignore the system query options and respond with `204 No Content`.

#### ##subsubsubsec Update Related Entities When Updating an Entity

Requests to change an entity with an OData-Version header with a value of `4.0` MUST
NOT contain related entities as inline content. Such requests MAY
contain binding information for navigation properties. For single-valued
navigation properties this replaces the relationship. For
collection-valued navigation properties this adds to the relationship.

Payloads with an `OData-Version` header with a value of `4.01` or
greater MAY include nested entities and entity references that specify
the full set of to be related entities, or a nested [delta
payload](#DeltaPayloads) representing the related entities that have
been added, removed, or changed. Such a request is referred to as a
"deep update". If the nested collection is represented identical to an
expanded navigation property, then the set of nested entities and entity
references specified in a successful request represents the full
set of entities to be related according to that relationship and MUST
NOT include added links, deleted links, or deleted entities.

If a navigation property is absent from a `PUT` or `PATCH` request payload, the referenced
or contained entity, or the collection thereof, remains unchanged by a successful update.

::: example
Example ##ex: using the JSON format, a 4.01 `PATCH` request can update a
manager entity. Following the update, the manager has three direct
reports; two existing employees and one new employee named
`Suzanne Brown`. The `LastName` of employee 6 is updated to `Smith`.

```json
{
  "@type": "#Northwind.Manager",
  "FirstName": "Patricia",
  "DirectReports": [
    {
      "@id": "Employees(5)"
    },
    {
      "@id": "Employees(6)",
      "LastName": "Smith"
    },
    {
      "FirstName": "Suzanne",
      "LastName": "Brown"
    }
  ]
}
```

:::

If the nested collection is represented as delta control information on the
navigation property, then the collection contains members to be added or
changed and MAY include deleted entities for entities that are no longer
part of the collection, using the [delta payload](#DeltaPayloads)
format. If the deleted entity specifies a `reason` as `deleted`, then
the entity is both removed from the collection and deleted, otherwise it
is removed from the collection and only deleted if the relationship is
contained. Non-key properties of the deleted entity are ignored. Nested
collections MUST NOT contain added or deleted links. If the request
contains nested delta collections, then the `PATCH` verb must be
specified.

If a nested entity has the same id or key fields as an existing entity,
the existing entity is updated according to the semantics of the `PUT` or
`PATCH` request. Nested entities that have no id or key fields, or for
which the id or key fields do not match existing entities, are treated
as inserts and processed observing the rules for [creating an entity](#CreateanEntity).
If any nested entities contain both id and key
fields, they MUST identify the same entity, or the request is invalid.

::: example
Example ##ex: using the JSON format, a 4.01 `PATCH` request can specify a
nested delta representation to:

- delete employee 3 and
  remove link to it
- remove the link to
  employee 4 and do not delete it
- add a link to employee
  5
- change the last name
  of employee 6 and link to it if necessary
- add a new employee
  named "Suzanne Brown" and link to it

```json
{
  "@type": "#Northwind.Manager",
  "FirstName": "Patricia",
  "DirectReports@delta": [
    {
      "@removed": {
        "reason": "deleted"
      },
      "@id": "Employees(3)"
    },
    {
      "@removed": {
        "reason": "changed"
      },
      "@id": "Employees(4)"
    },
    {
      "@id": "Employees(5)"
    },
    {
      "@id": "Employees(6)",
      "LastName": "Smith"
    },
    {
      "FirstName": "Suzanne",
      "LastName": "Brown"
    }
  ]
}
```
:::

::: example
Example ##ex: When updating an entity with a 4.01 `PUT` request, the target of a
non-containment navigation property can be replaced if the targeted entity is specified
by an entity reference (see [#OData-JSON#EntityReference]), without specifying all
its structural properties in `PUT` semantics.

The following JSON payload changes the name of a category and the products belonging
to it. (Compare this to [OData-JSON, example #OData-JSON#deepupdate].)
The effect would be the same if the `@context` was omitted from the request.
:::: side-by-side
::::: caption
Request
```json
PUT http://host/service/Categories(6)?$expand=Products
Content-Type: application/json

{
  "Name": "UpdatedCategory",
  "Products": [
    {
      "@context": "$metadata#$ref",
      "@id": "Products(57)"
    }
  ]
}
```
:::::
::::: caption
Response
```json
{
  "@context": "$metadata#Categories/$entity",
  "CategoryID": 6,
  "Name": "UpdatedCategory",
  "Products": [
    {
      "ProductID": 57,
      "Name": "Widgets"
    }
  ]
}
```
:::::
::::

If `Products` was a containment navigation property, the request and response
would be the same, except that the `@id` would likely be relative to the category,
for example, `Categories(6)/Products(57)`.

If the targeted entity in the payload contains some structural properties,
`PUT` resets all its other structural properties. The following alternative
payload resets the product name.
The effect would be the same if the `@id` was omitted from the request.
:::: side-by-side
```json
PUT http://host/service/Categories(6)?$expand=Products
Content-Type: application/json

{
  "Name": "UpdatedCategory",
  "Products": [
    {
      "@id": "Products(57)",
      "ProductID": 57
    }
  ]
}
```
```json
{
  "@context": "$metadata#Categories/$entity",
  "CategoryID": 6,
  "Name": "UpdatedCategory",
  "Products": [
    {
      "ProductID": 57,
      "Name": null
    }
  ]
}
```
::::
:::

Clients MAY associate an id with individual nested entities in the
request by using the
[Core.ContentID]{.term}
term defined in [OData-VocCore](#ODataVocCore). Services that respond
with [`200 OK`](#ResponseCode200OK) SHOULD annotate the entities in the response using the
same
[Core.ContentID]{.term}
value as specified in the request. Services SHOULD advertise support for
deep updates, including support for returning the
[Core.ContentID]{.term},
through the
[Capabilities.DeepUpdateSupport]{.term}
term, defined in [OData-VocCap](#ODataVocCap).

The `continue-on-error` preference is not supported for deep update
operations.

On failure, the service MUST NOT apply any of the changes specified in
the request.

#### ##subsubsubsec Upsert an Entity

Services MAY treat a request to change an entity as a [create entity request](#CreateanEntity)
if it requires the addressed entity to be newly created. The request is then said to be
"treated as an insert", otherwise "treated as an update".
Services that support this "upsert" capability (instead of failing such requests that require
entity creation) SHOULD advertise it by an annotation with the
term `Capabilities.UpdateRestrictions` (nested property `Upsertable`
with value `true`) defined in [OData-VocCap](#ODataVocCap).

If the resource path is not a canonical URL and the request is treated as an insert,
the service may be able to determine the canonical collection or canonical singleton (as defined in [section ##ContextURL]) for the newly-created entity
through a navigation property path binding [#OData-CSDL#NavigationPropertyPathBinding]
or through the presence of a context URL within the payload;
if the service is unable to determine it, it MUST fail the request.

Upserts are not supported against entities whose keys' values are
generated by the service. Services MUST fail a request to a URL
that would identify such an entity and the entity does not yet exist.

Similarly, services MUST fail an update request to the URL of a [media entity](#RequestingtheMediaStreamofaMediaEntityusingvalue) that does not yet exist.
However, a `PUT` request to the _media edit URL_ of a media entity does have upsert
semantics, in that the media entity is [created](#CreateaMediaEntity)
with the specified media stream if it does not already exist, otherwise the
media stream of the existing media entity is
[updated](#UpdateaMediaEntityStream).

A key property whose value is provided in the request URL SHOULD be omitted from the request body.
If key properties are provided in the request URL and the request body with different values,
services MUST either fail the request or ignore the value in the request body.

If the resource path is a canonical URL and the request
- contains an [`If-Match: *`](#HeaderIfMatch) header, the service MUST fail the request
  if it would be treated as an insert
- contains an `If-Match` header with an ETag as value, the service treats the request as
  an update if the [ETag](#UseofETagsforAvoidingUpdateConflicts) matches the addressed entity
  or fails the request, but never treats it as an insert
- contains an [`If-None-Match: *`](#HeaderIfNoneMatch) header, the service MUST fail the request
  if it would be treated as an update.

In other words, the `If-`(`None-`)`Match` header distinguishes between insert
and update in this case. Otherwise the resource path ends with a
non-containment navigation property and an `If-`(`None-`)`Match` header applies to
the current related entity addressed by it (see [example ##antietag]).

### ##subsubsec Delete an Entity

To delete an individual entity, the client makes a `DELETE` request to a
URL that identifies the entity. The [edit URL](#ReadURLsandEditURLs)
MAY differ from the canonical URL defined in [#OData-URL#CanonicalURL],
in which case clients SHOULD use the edit URL when deleting the entity.

The request body SHOULD be empty. Top-level singleton entities can be deleted if
they are nullable. Services supporting this MAY advertise it by
annotating the singleton with the term `Capabilities.DeleteRestrictions`
(nested property `Deletable` with value `true`) defined in
[OData-VocCap](#ODataVocCap).

On successful completion of the delete, the response MUST either be
[`204 No Content`](#ResponseCode204NoContent) and contain an empty body,
or [`200 OK`](#ResponseCode200OK) and contain a representation of a
deleted entity according to the specified format.

Services MUST implicitly remove relations to and from an entity when
deleting it; clients need not delete the relations explicitly.

Services MAY implicitly delete or modify related entities if required by
[integrity constraints](#HandlingofIntegrityConstraints). If integrity
constraints are declared in `$metadata` using a `ReferentialConstraint`
element, services MUST modify affected related entities according to the
declared integrity constraints, e.g. by deleting dependent entities, or
setting dependent properties to `null` or their default value.

One such integrity constraint results from using a navigation property
in a key definition of an entity type. If the related "key" entity is
deleted, the dependent entity is also deleted.

### ##subsubsec Modifying Relationships between Entities

Relationships between entities are represented by navigation properties
as described in [Data Model](#DataModel). URL conventions for navigation
properties are described in [#OData-URL#URLsforRelatedEntitieswithReferentialConstraints].

#### ##subsubsubsec Add a Reference to a Collection-Valued Navigation Property

A successful `POST` request to a navigation property's references
collection adds a relationship to an existing entity. The request body
MUST contain a single entity reference that identifies the entity to be
added. See the appropriate format document for details.

On successful completion, the response MUST be
[`204 No Content`](#ResponseCode204NoContent) and contain an empty body.

Note that if the two entities are already related prior to the request,
the request is completed successfully.

#### ##subsubsubsec Remove a Reference to an Entity

A successful `DELETE` request to the URL that represents a reference to
a related entity removes the relationship to that entity.

In OData 4.0, the entity reference to be removed within a
collection-valued navigation property is the URL that represents the
collection of related references, with the reference to be removed
identified by the [`$id`](#ResolvinganEntityId) query option. OData 4.01
services additionally support using the URL that represents the
reference of the collection member to be removed, identified by key, as
described in [#OData-URL#AddressingReferencesbetweenEntities].

For single-valued navigation properties, the
[`$id`](#ResolvinganEntityId) query option MUST NOT be specified.

The `DELETE` request MUST NOT violate any [integrity
constraints](#HandlingofIntegrityConstraints) in the data model.

On successful completion, the response MUST be
[`204 No Content`](#ResponseCode204NoContent) and contain an empty body.

#### ##subsubsubsec Change the Reference in a Single-Valued Navigation Property

A successful `PUT` request to a single-valued navigation property's
reference resource changes the related entity. The request body MUST
contain a single entity reference that identifies the existing entity to
be related. See the appropriate format document for details.

On successful completion, the response MUST be
[`204 No Content`](#ResponseCode204NoContent) and contain an empty body.

Alternatively, a relationship MAY be updated as part of an update to the
source entity by including the required binding information for the new
target entity. This binding information is format-specific, see
[#OData-JSON#RelatedEntities] for details.

If the single-valued navigation property is used in the key definition
of an entity type, it cannot be changed and the request MUST fail with
[`405 Method Not Allowed`](#ResponseCode405MethodNotAllowed) or an other
appropriate error.

#### ##subsubsubsec Replace all References in a Collection-Valued Navigation Property

A successful `PUT` request to a collection-valued navigation property's
reference resource replaces the set of related entities. The request
body MUST contain a collection of entity references in the same format
as returned by a `GET` request to the navigation property's reference
resource.

A successful `DELETE` request to a collection-valued navigation
property's reference resource removes all related references from the
collection.

### ##subsubsec Managing Media Entities

A [media entity](#RequestingtheMediaStreamofaMediaEntityusingvalue) MUST have a
source URL that can be used to read the media stream, and MAY have a
media edit URL that can be used to write to the media stream.

Because a media entity has both a media stream and standard entity
properties special handling is required.

#### ##subsubsubsec Create a Media Entity

A `PUT` request to the media edit URL of a null-valued singleton media entity
(by convention, the resource path of the media entity URL appended with `/$value`),
or a `POST` request to a media entity's entity set, create a new media
entity. The request body MUST contain the media value (for example, the
photograph) whose media type MUST be specified in a
[`Content-Type`](#HeaderContentType) header. The request body is always
interpreted as the media value, even if it has the media type of an
OData format supported by the service. The service may set other structural
properties of the media entity upon creation, but it is not possible
for clients to specify structural properties when creating the media
entity.

Upon successful completion, the response MUST contain
[`Location`](#HeaderLocation) header that contains the edit URL of the created media
entity.

Upon successful completion the service responds with either
[`201 Created`](#ResponseCode201Created), or
[`204 No Content`](#ResponseCode204NoContent) if the request included a
[`return=minimal`](#Preferencereturnrepresentationandreturnminimal) preference.

#### ##subsubsubsec Update a Media Entity Stream

A successful `PUT` request to the media edit URL of an existing media entity
changes the media stream of the entity.

If the media entity did not previously exist, then the request is interpreted as a
creation request according to [Create a Media Entity](#CreateaMediaEntity)

If the entity includes an ETag value for the media stream, the client
MUST include an [`If-Match`](#HeaderIfMatch) header with the ETag value.

The request body MUST contain the new media value for the entity whose
media type MUST be specified in a [`Content-Type`](#HeaderContentType)
header.

The service may set other structural properties of the media entity when updating
the media entity stream, but it is not possible for clients to specify structural
properties when updating the media entity stream.

On success, the service MUST respond with either
[`204 No Content`](#ResponseCode204NoContent) and an empty body, or
[`200 OK`](#ResponseCode200OK) if the client specified the preference
[`return=representation`](#Preferencereturnrepresentationandreturnminimal), in
which case the response body MUST contain the updated media entity.

#### ##subsubsubsec Delete a Media Entity

A successful `DELETE` request to the entity's edit URL or to the edit
URL of its media stream deletes the media entity as described in [Delete
an Entity](#DeleteanEntity).

Deleting a media entity also deletes the media associated with the
entity.

### ##subsubsec Managing Stream Properties

An entity may have one or more _stream properties_. Stream properties
are properties of type `Edm.Stream`.

The values for stream properties do not usually appear in the entity
payload unless explicitly requested with [`$expand`](#SystemQueryOptionexpand).
Instead, the values are generally read or written through URLs.

::: example
Example ##ex_entityWithStreamProperty: read an entity and select a stream property

```
GET http://host/service/Products(1)?$select=Thumbnail
```

would only include control information for the stream property, not the stream data itself

```json
{
  "@context": "http://host/service/$metadata#Products/$entity",
  …
  "Thumbnail@mediaReadLink": "http://server/Thumbnail546.jpg",
  "Thumbnail@mediaEditLink": "http://server/uploads/Thumbnail546.jpg",
  …
}
```

The stream data can then be requested using the media read link:

```
GET http://server/Thumbnail546.jpg
```

:::

Services SHOULD support direct property access to a stream property's canonical URL.
The response MAY be a redirect to the media read link of the stream property
if the media read link is different from the canonical URL.

::: example
Example ##ex: directly read a stream property of an entity

```
GET http://host/service/Products(1)/Thumbnail
```

can return [`200 OK`](#ResponseCode200OK) and the stream data (see [section ##RequestingStreamProperties]),
or a [`3xx Redirect`](#ResponseCode3xxRedirection) to the media read link of the stream property.
:::

Note: for scenarios in which the media value can only be inlined,
the property should instead be modeled with type `Edm.Binary`.

#### ##subsubsubsec Update Stream Values

A successful `PUT` request to the edit URL of a stream property changes
the media stream associated with that property.

If the stream metadata includes an ETag value, the client SHOULD include
an [`If-Match`](#HeaderIfMatch) header with the ETag value.

The request body MUST contain the new media value for the stream whose
media type MUST be specified in a [`Content-Type`](#HeaderContentType)
header. It may have a `Content-Length` of zero to set the stream data to
empty.

Stream properties MAY specify a list of acceptable media types using an
annotation with term
[Core.AcceptableMediaTypes]{.term},
see [OData-VocCore](#ODataVocCore).

On success, the service MUST respond with either
[`204 No Content`](#ResponseCode204NoContent) and an empty body, or
[`200 OK`](#ResponseCode200OK) if the client specified the preference
[`return=representation`](#Preferencereturnrepresentationandreturnminimal), in
which case the response body MUST contain the updated media value for
the stream.

Clients MAY change the association between a stream property and a media
stream by modifying the edit URL or read URL of the stream property.
Services supporting this SHOULD advertise it by annotating the stream
property with the term `Capabilities.MediaLocationUpdateSupported`
defined in [OData-VocCap](#ODataVocCap).

#### ##subsubsubsec Delete Stream Values

A successful `DELETE` request to the edit URL of a stream property
attempts to set the property to null and results in an error if the
property is non-nullable.

::: example
Example ##ex: delete the stream value using the media edit link retrieved in [example ##entityWithStreamProperty]

```
DELETE http://server/uploads/Thumbnail546.jpg
```

:::

Attempting to request a stream property whose value is null results in
[`204 No Content`](#ResponseCode204NoContent).

### ##subsubsec Managing Values and Properties Directly

Values and properties can be explicitly addressed with URLs. The edit
URL of a property is the edit URL of the entity appended with the path
segment(s) specifying the individual property. The edit URL allows
properties to be individually modified. See [#OData-URL#AddressingaProperty] for
details on addressing individual properties.

#### ##subsubsubsec Update a Primitive Property

A successful `PUT` request to the edit URL for a primitive property
updates the value of the property. The message body MUST contain the new
value, formatted as a single property according to the specified format.

A successful `PUT` request to the edit URL for the [raw
value](#RequestingaRawValueusingvalue) of a primitive property
updates the property with the raw value specified in the payload. The
payload MUST be formatted as an appropriate content type for the raw
value of the property.

The same rules apply whether this is a regular property or a dynamic
property.

Upon successful completion the service responds with either
[`200 OK`](#ResponseCode200OK) or
[`204 No Content`](#ResponseCode204NoContent). The client may request
that the response SHOULD include a body by specifying a
[`return=representation`](#Preferencereturnrepresentationandreturnminimal) preference.

Services MUST return an error if the property is not updatable.

#### ##subsubsubsec Set a Value to Null

A successful `DELETE` request to the edit URL for a structural property,
or to the edit URL of the [raw
value](#RequestingaRawValueusingvalue) of a primitive property,
sets the property to null. The request body is ignored and should be
empty.

A `DELETE` request to a non-nullable value MUST fail and the service
respond with `400 Bad Request` or other appropriate error.

The same rules apply whether the target is the value of a regular
property or the value of a dynamic property. A missing dynamic property
is defined to be the same as a dynamic property with value `null`. All
dynamic properties are nullable.

On success, the service MUST respond with [`204 No Content`](#ResponseCode204NoContent) and an empty
body.

Services MUST return an error if the property is not updatable.

[Updating a primitive property](#UpdateaPrimitiveProperty) or a [complex
property](#UpdateaComplexProperty) with a null value also sets the
property to null.

#### ##subsubsubsec Update a Complex Property

A successful `PATCH` request to the edit URL for a complex typed
property updates that property. The request body MUST contain a single
valid representation for the declared type of the complex property or one of its derived types.

The service MUST directly modify only those properties of the complex
type specified in the payload of the `PATCH` request.

If a complex-typed property is set to a different type in a `PATCH` request,
properties shared through inheritance, as well as dynamic properties,
are retained (unless overwritten by new values in the payload).
Other properties of the original type are discarded.

The service MAY additionally support clients sending a `PUT` request to
a URL that specifies a complex type. In this case, the service MUST
replace the entire complex property with the values specified in the
request body and set all unspecified properties to their default value.

Upon successful completion the service responds with either
[`200 OK`](#ResponseCode200OK) or
[`204 No Content`](#ResponseCode204NoContent). The client may request
that the response SHOULD include a body by specifying a
[`return=representation`](#Preferencereturnrepresentationandreturnminimal) preference.

Services MUST return an error if the property is not updatable.

#### ##subsubsubsec Update a Collection Property

A successful `PUT` request to the edit URL of a collection property
updates that collection. The message body MUST contain the desired new
value, formatted as a collection property according to the specified
format.

The service MUST replace the entire value with the value supplied in the
request body.

A successful `POST` request to the edit URL of a collection property
adds an item to the collection. The body of the request MUST be a single
item to be added to the collection. If the collection is ordered, the
item is added to the end of the collection, and if the collection supports positional insert
[`$index`](#RequestinganIndividualMemberofanOrderedCollection) MAY be used to specify
the insert position.

A successful `DELETE` request to the edit URL of a collection property
deletes all items in that collection.

Since collection members have no individual identity, `PATCH` is not
supported for collection properties.

Upon successful completion the service responds with either
[`200 OK`](#ResponseCode200OK) and a representation of the updated collection, or
[`204 No Content`](#ResponseCode204NoContent). The client may request
that the response SHOULD include a body by specifying a
[`return=representation`](#Preferencereturnrepresentationandreturnminimal) preference.

Services MUST return an error if the property is not updatable.

### ##subsubsec Managing Members of an Ordered Collection

Collections annotated with the
[Core.Ordered]{.term}
term (see [OData-VocCore](#ODataVocCore)) have a stable order. Members
of an ordered collection of primitive and complex types can be
individually updated or deleted by invoking an update operation against
the URL of the collection appended by a segment containing the
zero-based ordinal of the item within the collection. A negative ordinal
number indexes from the end of the collection, with -1 representing the
last item in the collection.

Entities can be updated using their edit URL and SHOULD NOT be addressed
using an index.

### ##subsubsec Positional Inserts

Collections of entity, complex, or primitive types annotated with the
[Core.PositionalInsert]{.term}
term (see [OData-VocCore](#ODataVocCore)) support inserting items at a
specific location via `POST` requests to the collection URL using the
`$index` system query option. The value of the `$index` system query
option is the zero-based ordinal position where the item is to be
inserted. The ordinal positions of items within the collection greater
than or equal to the inserted position are increased by one. A negative
ordinal number indexes from the end of the collection, with -1
representing an insert as the last item in the collection.

::: example
Example ##ex: Insert a new email address at the second position

```json
POST /service/Customers('ALFKI')/EmailAddresses?$index=1
Content-Type: application/json

{
  "value": "alfred@futterkiste.de"
}
```

:::

### ##subsubsec Update a Collection of Entities

Collections of entities can be updated by submitting a `PATCH` request
to the resource path of the collection. The body of the request MUST be
a [delta payload](#DeltaPayloads), and the resource path of the
collection MUST NOT contain type cast or filter segments, and MUST NOT
contain any system query options that affect the shape of the result.

Added/changed entities are applied as [upserts](#UpsertanEntity), and
deleted entities as [deletions](#DeleteanEntity). Non-key properties of
deleted entities are ignored. The top-level collection may include added
and deleted links, and related entities represented inline are updated
according to the rules for [treating related entities when updating an
entity](#UpdateRelatedEntitiesWhenUpdatinganEntity).

Clients MAY associate an id with individual nested entities in the
request by using the
[Core.ContentID]{.term}
term defined in [OData-VocCore](#ODataVocCore). Services that respond
with [`200 OK`](#ResponseCode200OK) SHOULD annotate the entities in the response using the
same
[Core.ContentID]{.term}
value as specified in the request.

Services SHOULD advertise support for updating a collection using a
delta payload through the `DeltaUpdateSupported` property of the
[Capabilities.UpdateRestrictions]{.term}
term, and SHOULD advertise support for returning the
[Core.ContentID]{.term}
through the `ContentIDSupported` property of the
[Capabilities.DeepUpdateSupport]{.term}
term, both defined in [OData-VocCap](#ODataVocCap).

For each entity being updated or removed, clients MAY specify an [ETag](#UseofETagsforAvoidingUpdateConflicts) value obtained from a previous request.
If an ETag is provided that does not match the ETag value of the entity being updated or removed,
or if an ETag is provided when adding or updating an entity that does not currently exist,
then services that support ETags MUST NOT apply the change and instead
[report](#ErrorHandlingwhenUpdatingaCollectionofEntities) a `412 Precondition Failed` error.
The special value `*` can be used to match any existing entity but fail if the entity does not already exist.

Added/changed entities that specify format-specific control information
equivalent to an `If-Match-None: *` header [#OData-JSON#ControlInformationetagodataetag]
MUST NOT be treated as an update.

The response, if requested, is a delta payload, in the same structure
and order as the request payload, representing the applied changes.

#### ##subsubsubsec Error Handling when Updating a Collection of Entities

If the `continue-on-error` preference has not been applied, and the
service is unable to apply all of the changes in the request, then it
MUST return an error response and MUST NOT apply any of the changes
specified in the request payload.

If the [`continue-on-error`](#Preferencecontinueonerrorodatacontinueonerror) preference
has been applied and any errors occur in processing the changes, then a delta response MUST be returned
regardless of the [`return`](#Preferencereturnrepresentationandreturnminimal)
preference and MUST contain at least the failed changes. The service
represents failed changes in the delta response as follows:

- Failed deletes in the request MUST be represented in the response as either entities
  or entity references, annotated with the term `Core.DataModificationException`, see
  [OData-VocCore](#ODataVocCore). If the deleted entity specified a reason
  of `deleted`, or the target collection is an entity set or containment navigation property,
  then the value of `failedOperation` MUST be `delete`, otherwise `unlink`.
- Failed inserts within the request MUST
  be represented in the response as deleted entities annotated with the term
  `Core.DataModificationException` with a `failedOperation` value of
  `insert`.
- Failed updates within the request SHOULD be annotated in the response with
  the term `Core.DataModificationException` with a `failedOperation` value of `update`.
- Failed added links within the request MUST be represented in the response as
  deleted links annotated with the term `Core.DataModificationException`
  with a `failedOperation` value of `link`.
- Failed deleted links within the request MUST be represented in the response as
  added links annotated with the term `Core.DataModificationException`
  with a `failedOperation` value of `unlink`.
- Delta collections within the request are returned as delta collections in the
  response, according to these same rules.
- Collections within the request are represented as collections in the response
  according to the rules specified in [Replace a Collection of Entities](#ErrorHandlingwhenReplacingaCollectionofEntities).

If an individual change fails due to a failed dependency, it MUST be
annotated with the term [Core.DataModificationException]{.term} and SHOULD specify
a `responseCode` of `424` ([Failed Dependency](#ResponseCode424FailedDependency)).

If no `continue-on-error` preference is applied, the collection update MUST happen
in an [atomic](#Atomicity) manner.

### ##subsubsec Replace a Collection of Entities

Collections of entities can be replaced by submitting a `PUT` request
to the resource path of the collection. The body of the request MUST be
the representation of the complete collection of replacement entities. In this
case all entities provided in the request are applied as
[upserts](#UpsertanEntity), and any entities not provided in the request
are deleted.

For each entity being updated, clients MAY specify an [ETag](#UseofETagsforAvoidingUpdateConflicts)
value obtained from a previous request. If an ETag is provided that does not match the ETag
value of the entity being updated, or if an ETag is provided for an entity that does not
currently exist, then services that support ETags MUST NOT apply the
change and instead [report](#ErrorHandlingwhenReplacingaCollectionofEntities)
a `412 Precondition Failed`. The special ETag value `*` can be used to match any existing entity
but fail if the entity does not already exist.

#### ##subsubsubsec Error Handling when Replacing a Collection of Entities

If the `continue-on-error` preference has not been applied, and the
service is unable to apply all of the changes in the request, then it
MUST return an error response and MUST NOT apply any of the changes
specified in the request payload.

If the `continue-on-error` preference has been applied and any errors occur
in processing the changes, then a response MUST be returned regardless of the
[`return`](#Preferencereturnrepresentationandreturnminimal) preference, and MUST
contain the full membership and values of the collection as it exists in
the service, as follows:

- Entities missing in the request that cannot be removed from the collection
  MUST be represented in the response as either entities or entity references,
  and SHOULD be annotated with the term `Core.DataModificationException`, see
  [OData-VocCore](#ODataVocCore). If the target collection is an entity set or
  containment navigation property, then the value of `failedOperation` MUST be
  `delete`, otherwise `unlink`.
- Failed inserts within the request MUST NOT be represented in the response.
- Failed updates within the request MUST be represented in the response with
  their current values and SHOULD be annotated with the term `Core.DataModificationException`
  with a `failedOperation` value of `update`.
- Collections within the request MUST also be represented in the response
  following these same rules.

If no `continue-on-error` preference is applied, the collection update MUST happen
in an [atomic](#Atomicity) manner.

### ##subsubsec Update Members of a Collection

Members of a collection can be updated by submitting a `PATCH` request
to the URL constructed by appending `/$each` to the resource path of the
collection. The additional path segment expresses that the request body
describes an update to each member of the collection, not an update to
the collection itself.

The resource path of the collection MAY contain type-cast or filter
segments to subset the collection, see [#OData-URL#AddressingDerivedTypes] and
[#OData-URL#AddressingaSubsetofaCollection].

For primitive-typed collections the body of the request MUST be a
primitive value. Each member of the potentially filtered collection is
updated to the specified primitive value.

For collections of structured type, the body of the request MUST be a
full or partial representation of an instance of the collection's
structured type. Each member of the potentially filtered collection is
[updated](#UpdateanEntity) using `PATCH` semantics. Structured types MAY
include nested collections or delta collections, in which case the
semantics described in [Update a Collection of
Entities](#UpdateaCollectionofEntities) applies.

::: example
Example ##ex: change the color of all beige-brown products

```json
PATCH /service/Products/$filter(@bar)/$each?@bar=Color eq 'beige-brown'
Content-Type: application/json

{
  "Color": "taupe"
}
```

:::

The response, if requested, is a collection payload containing the
updated representation of each member identified by the request. If the
update payload includes nested collections or nested delta collections,
then they MUST be included in the response, as described in [Update a
Collection of Entities](#UpdateaCollectionofEntities).

Clients should note that requesting a response may be expensive for
services that could otherwise efficiently apply updates to a (possibly
filtered) collection.

If the `continue-on-error` preference has been specified, the service
MAY continue processing updates after a failure. In this case, the
service MUST return a response containing at least the members of the
collection that failed to update, which MUST be annotated with the term
`Core.DataModificationException` with a `failedOperation` value of
`update`.

If the `continue-on-error` preference has not been specified, and the
service is unable to update all of the members identified by the
request, then it MUST return an error response and MUST NOT apply any
updates.

If no `continue-on-error` preference is applied, the collection update MUST happen
in an [atomic](#Atomicity) manner.

### ##subsubsec Delete Members of a Collection

Members of a collection can be deleted by submitting a `DELETE` request
to the URL constructed by appending `/$each` to the resource path of the
collection. The additional path segment expresses that the collection
itself is not deleted.

The request resource path of the collection MAY contain type-cast or
filter segments to subset the collection.

::: example
Example ##ex: delete all products older than 3

```
DELETE /service/Products/$filter(Age gt 3)/$each
```

:::

If the path identifies a collection of entities and if the service
returns a representation, then the response is a delta response
containing a representation of a deleted entity for each deleted member.

If the collection is a collection of entities, then the client MAY
specify the `continue-on-error` preference, in which case the service
MAY continue processing deletes after a failure. In this case, the
service MUST return a response containing at least an entity or entity
reference for each entity identified by the request that failed to
delete, which MUST be annotated with the term
`Core.DataModificationException` with a `failedOperation` value of
`delete`.

Clients should note that requesting a response may be expensive for
services that could otherwise efficiently apply deletes to a (possibly
filtered) collection.

If the `continue-on-error` preference has not been specified, and the
service is unable to delete all of the entities identified by the
request, then it MUST return an error response and MUST NOT apply any
changes.

If no `continue-on-error` preference is applied, the deletion MUST happen
in an [atomic](#Atomicity) manner.
